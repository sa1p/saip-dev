---
import Layout from "../layouts/Layout.astro";
import MagneticButton from "../components/MagneticButton";
import TiltCard from "../components/TiltCard";
import saipChan01 from "../assets/videos/saip-chan/saip-chan-01.mp4";
import saipChan02 from "../assets/videos/saip-chan/saip-chan-02.mp4";
import saipChan03 from "../assets/videos/saip-chan/saip-chan-03.mp4";
import saipChan04 from "../assets/videos/saip-chan/saip-chan-04.mp4";
import saipChan05 from "../assets/videos/saip-chan/saip-chan-05.mp4";
import saipChan06 from "../assets/videos/saip-chan/saip-chan-06.mp4";
import phonePoster from "../assets/images/saip-chan/saip-chan-poster.jpg";
import lockScreenImage from "../assets/images/saip-chan/saip-chan-lock.jpg";
import profileImage from "../assets/images/profile/saip-profile.jpg";

const phoneVideos = [
  saipChan01,
  saipChan02,
  saipChan03,
  saipChan04,
  saipChan05,
  saipChan06,
];
const phoneVideoPlaylist = JSON.stringify(phoneVideos);
---

<Layout
  title="Saip | AI Producer & Engineer"
  description="AI×エンタメ領域で、プロダクト開発からコミュニティ運営までを一気通貫で手がけるポートフォリオ。"
>
  <main class="page">
    <section class="hero">
      <div data-reveal>
        <p class="hero__eyebrow">AI Producer / Engineer</p>
        <h1 class="hero__title">
          Designing the intersection of <span class="hero__title-accent"
            >AI & Emotion</span
          >.
        </h1>
        <p class="hero__lead">
          AI×エンタメの企画から実装、コミュニティまで。静かな熱量で体験を磨き上げます。
        </p>
        <div class="cta-row">
          <MagneticButton
            client:load
            href="mailto:hello@tr1ppy.com"
            label="Contact"
          />
          <MagneticButton
            client:load
            href="#works"
            label="View Works"
            variant="ghost"
          />
        </div>
        <div class="hero__meta">
          <span><strong>Saip (さいぴ)</strong> / AI Producer</span>
          <span>Trippy Inc. / AI × Entertainment</span>
        </div>
      </div>
      <div
        class="hero__visual hero__visual--phone"
        data-reveal
        style="--delay: 0.1s;"
      >
        <div class="hero__grid" aria-hidden="true"></div>
        <div class="hero__phone">
          <div class="hero__phone-notch"></div>
          <div class="hero__phone-buttons" aria-hidden="true">
            <button
              class="hero__phone-button hero__phone-button--mute"
              type="button"
              aria-label="Mute toggle"
              data-phone-mute></button>
            <button
              class="hero__phone-button hero__phone-button--up"
              type="button"
              aria-label="Volume up"
              data-phone-volume-up></button>
            <button
              class="hero__phone-button hero__phone-button--down"
              type="button"
              aria-label="Volume down"
              data-phone-volume-down></button>
          </div>
          <button
            class="hero__phone-button hero__phone-button--power"
            type="button"
            aria-label="Power"
            data-phone-power></button>
          <div class="hero__phone-status">
            <span class="hero__phone-time" data-phone-time>09:41</span>
            <span class="hero__phone-status-icons">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path
                  d="M2 18h2.5v-3H2v3Zm4.5 0H9v-6H6.5v6Zm4.5 0H13.5V7H11v11Zm4.5 0H18v-9h-2.5v9Zm4.5 0H23v-12h-2.5v12Z"
                  fill="currentColor"></path>
              </svg>
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path
                  d="M12 4c2.5 0 4.7 1.2 6.2 3.1l-1.6 1.2C15.5 6.8 13.9 6 12 6s-3.5.8-4.6 2.3L5.8 7.1C7.3 5.2 9.5 4 12 4Zm0 6c1.4 0 2.7.7 3.5 1.8l-1.6 1.2c-.5-.7-1.2-1-1.9-1s-1.4.3-1.9 1l-1.6-1.2C9.3 10.7 10.6 10 12 10Zm0 6c.6 0 1.2.3 1.6.8l-1.6 1.2-1.6-1.2c.4-.5 1-.8 1.6-.8Z"
                  fill="currentColor"></path>
              </svg>
              <svg viewBox="0 0 28 14" aria-hidden="true">
                <rect
                  x="1"
                  y="3"
                  width="22"
                  height="8"
                  rx="2"
                  stroke="currentColor"
                  stroke-width="1.5"
                  fill="none"></rect>
                <rect
                  x="3"
                  y="5"
                  width="14"
                  height="4"
                  rx="1"
                  fill="currentColor"></rect>
                <rect
                  x="23"
                  y="5.5"
                  width="3"
                  height="3"
                  rx="1"
                  fill="currentColor"></rect>
              </svg>
            </span>
          </div>
          <div class="hero__phone-screen">
            <video
              class="hero__phone-video"
              autoplay
              muted
              playsinline
              poster={phonePoster.src}
              src={phoneVideos[0]}
              data-video-playlist={phoneVideoPlaylist}></video>
            <div class="hero__phone-screen-overlay">
              <div class="hero__phone-volume" aria-hidden="true">
                <div class="hero__phone-volume-bar">
                  <span class="hero__phone-volume-fill"></span>
                </div>
              </div>
              <div class="hero__phone-bottom"></div>
            </div>
            <div class="hero__phone-chat">
              <div class="chat-log" data-chat-log></div>
              <form class="chat-form" data-chat-form>
                <input
                  class="chat-input"
                  name="message"
                  type="text"
                  placeholder="なんでも答えてくれるさいぴちゃん"
                  required
                  maxlength="50"
                  inputmode="text"
                  enterkeyhint="send"
                  autocomplete="off"
                />
                <div class="chat-actions">
                  <button class="chat-send" type="submit" data-chat-submit
                    >Send</button
                  >
                  <span class="chat-note" data-chat-status></span>
                </div>
              </form>
            </div>
            <button class="hero__lock-screen" type="button" data-lock-screen>
              <img
                class="hero__lock-video"
                src={lockScreenImage.src}
                alt=""
                aria-hidden="true"
                decoding="async" />
              <div class="hero__lock-overlay">
                <span class="hero__lock-time" data-phone-lock-time>09:41</span>
                <span class="hero__lock-date" data-phone-lock-date
                  >Mon, Jan 1</span
                >
                <span class="hero__lock-hint">Tap to unlock</span>
              </div>
            </button>
          </div>
        </div>
      </div>
    </section>

    <section id="works">
      <div class="section-intro" data-reveal style="--delay: 0.05s;">
        <p class="section-intro__eyebrow">Portfolio</p>
        <h2 class="section-intro__title">Works & Focus</h2>
        <p class="section-intro__lead">
          AI×エンタメ領域の実績と強みを、必要な情報だけで端的にまとめています。
        </p>
      </div>

      <div class="bento-grid">
        <div
          class="col-span-12 md:col-span-7 md:row-span-2"
          data-reveal
          style="--delay: 0.05s;"
        >
          <TiltCard client:visible className="bento-card h-full">
            <p class="card-eyebrow">About</p>
            <h3 class="card-title">Saip (さいぴ)</h3>
            <p class="card-desc">
              株式会社Trippy 所属。「AI×エンタメ」領域のプロダクト開発において、
              企画・実装・コミュニティ運営を一気通貫で手がける。代表作『オズチャット
              -Oz Chat-』はユーザー数16万人を突破。LLMによるキャラクター対話や
              生成AIを活用したクリエイティブ制作を得意とする。
            </p>
            <div class="tag-row">
              <span class="tag">AI Product</span>
              <span class="tag">Full-Stack Dev</span>
              <span class="tag">Generative AI</span>
              <span class="tag">Community</span>
            </div>
          </TiltCard>
        </div>

        <div
          class="bento-card col-span-12 md:col-span-5 md:row-span-2"
          data-reveal
          style="--delay: 0.1s;"
        >
          <div class="avatar-card">
            <div class="avatar">
              <img src={profileImage.src} alt="Saip profile" loading="lazy" />
            </div>
            <div>
              <p class="card-title">@_saip_</p>
              <p class="card-desc">AI×エンタメの企画・実装・発信を継続中。</p>
              <div class="link-list">
                <a
                  class="text-link"
                  href="https://x.com/_saip_"
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  X (DM)
                </a>
                <a class="text-link" href="mailto:hello@tr1ppy.com">Email</a>
                <a
                  class="text-link"
                  href="https://tr1ppy.com"
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  Company
                </a>
              </div>
            </div>
          </div>
        </div>

        <a
          class="block col-span-12 md:col-span-8 md:row-span-2"
          data-reveal
          style="--delay: 0.15s;"
          href="https://0z.chat"
          target="_blank"
          rel="noopener noreferrer"
          aria-label="オズチャット -Oz Chat- 公式サイト"
        >
          <TiltCard
            client:visible
            className="bento-card bento-card--accent h-full"
          >
            <p class="card-eyebrow">Flagship</p>
            <h3 class="card-title">オズチャット -Oz Chat-</h3>
            <p class="card-desc">
              AIキャラクターと通話できる没入型チャットアプリ。感情表現と対話体験を
              拡張するプロダクトとして設計。
            </p>
            <div class="card-footer">
              <span class="tag">AI Character Voice</span>
              <span class="card-link">Visit</span>
            </div>
          </TiltCard>
        </a>

        <div
          class="bento-card col-span-12 md:col-span-4"
          data-reveal
          style="--delay: 0.2s;"
        >
          <p class="card-eyebrow">Focus</p>
          <h3 class="card-title">Value Design</h3>
          <p class="card-desc">
            企画から実装までを最短距離でつなぎ、体験価値を引き上げます。
          </p>
          <div class="stack-grid">
            <div class="stack-item">Product Strategy</div>
            <div class="stack-item">AI Experience</div>
            <div class="stack-item">Rapid Prototyping</div>
            <div class="stack-item">Community Growth</div>
          </div>
        </div>

        <div
          class="bento-card col-span-12 md:col-span-4"
          data-reveal
          style="--delay: 0.25s;"
        >
          <p class="card-eyebrow">Creative</p>
          <h3 class="card-title">Manga & Creative</h3>
          <p class="card-desc">AIとマンガ表現を融合させたコンテンツ発信。</p>
          <a
            class="text-link"
            href="https://x.com/_saip_"
            target="_blank"
            rel="noopener noreferrer"
          >
            View on X
          </a>
        </div>

        <div
          class="bento-card col-span-12 md:col-span-4"
          data-reveal
          style="--delay: 0.3s;"
        >
          <p class="card-eyebrow">Media / Talk</p>
          <h3 class="card-title">Selected Media</h3>
          <p class="card-desc">
            外部メディア掲載や登壇などの記録をまとめています。
          </p>
          <div class="media-logos">
            <span class="logo-pill">PR TIMES</span>
            <span class="logo-pill">Talks</span>
            <span class="logo-pill">Interview</span>
            <span class="logo-pill">Podcast</span>
          </div>
        </div>

        <div
          id="contact"
          class="bento-card bento-card--ink col-span-12"
          data-reveal
          style="--delay: 0.35s;"
        >
          <p class="card-eyebrow">Contact</p>
          <h3 class="card-title">新しいAIエンタメ体験を共創しませんか</h3>
          <p class="card-desc">
            お仕事のご依頼、取材、コラボレーションのご相談はこちらから。
          </p>
          <form
            class="contact-form"
            method="POST"
            action="/api/contact"
            data-contact-form
          >
            <div class="form-grid form-grid--two">
              <label class="form-field">
                <span class="form-label">Name</span>
                <input
                  class="form-input"
                  type="text"
                  name="name"
                  autocomplete="name"
                  required
                />
              </label>
              <label class="form-field">
                <span class="form-label">Email</span>
                <input
                  class="form-input"
                  type="email"
                  name="email"
                  autocomplete="email"
                  required
                />
              </label>
            </div>
            <label class="form-field form-honeypot" aria-hidden="true">
              <span class="form-label">Website</span>
              <input
                class="form-input"
                type="text"
                name="website"
                tabindex="-1"
                autocomplete="off"
              />
            </label>
            <label class="form-field">
              <span class="form-label">Message</span>
              <textarea class="form-textarea" name="message" rows="5" required
              ></textarea>
            </label>
            <div class="form-actions">
              <button class="form-button" type="submit" data-contact-submit>
                Send
              </button>
              <span class="form-note">通常24時間以内に返信します。</span>
            </div>
            <p
              class="form-status"
              role="status"
              aria-live="polite"
              data-contact-status
            >
            </p>
          </form>
          <div class="contact-links">
            <a class="cta-link" href="mailto:hello@tr1ppy.com">Email</a>
            <a
              class="cta-link"
              href="https://x.com/_saip_"
              target="_blank"
              rel="noopener noreferrer"
            >
              X DM
            </a>
          </div>
        </div>
      </div>
    </section>

    <footer class="footer">&copy; {new Date().getFullYear()} Saip.</footer>
  </main>

  <script is:inline>
    (() => {
      const elements = document.querySelectorAll("[data-reveal]");
      if (!elements.length) return;

      const reduceMotion = window.matchMedia(
        "(prefers-reduced-motion: reduce)"
      ).matches;
      if (reduceMotion || !("IntersectionObserver" in window)) {
        elements.forEach((el) => el.classList.add("is-visible"));
        return;
      }

      const observer = new IntersectionObserver(
        (entries, obs) => {
          entries.forEach((entry) => {
            if (!entry.isIntersecting) return;
            entry.target.classList.add("is-visible");
            obs.unobserve(entry.target);
          });
        },
        { threshold: 0.15 }
      );

      elements.forEach((el) => observer.observe(el));
    })();
  </script>
  <script is:inline>
    (() => {
      const timeEl = document.querySelector("[data-phone-time]");
      const lockTimeEl = document.querySelector("[data-phone-lock-time]");
      const lockDateEl = document.querySelector("[data-phone-lock-date]");
      if (!timeEl && !lockTimeEl && !lockDateEl) return;

      const dateFormatter = new Intl.DateTimeFormat("ja-JP", {
        weekday: "short",
        month: "short",
        day: "numeric",
      });

      const updateTime = () => {
        const now = new Date();
        const hours = now.getHours().toString().padStart(2, "0");
        const minutes = now.getMinutes().toString().padStart(2, "0");
        const timeText = `${hours}:${minutes}`;
        if (timeEl) timeEl.textContent = timeText;
        if (lockTimeEl) lockTimeEl.textContent = timeText;
        if (lockDateEl) lockDateEl.textContent = dateFormatter.format(now);
      };

      updateTime();
      setInterval(updateTime, 1000);
    })();
  </script>
  <script is:inline>
    (() => {
      const wrapper = document.querySelector(".hero__visual--phone");
      const phone = wrapper?.querySelector(".hero__phone");
      if (!wrapper || !phone) return;

      if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;

      const maxTilt = 9;
      const maxDepth = 18;
      let lastEvent = null;
      let rafId = null;

      const updateTilt = () => {
        if (!lastEvent) return;
        const rect = wrapper.getBoundingClientRect();
        const relX = (lastEvent.clientX - rect.left) / rect.width;
        const relY = (lastEvent.clientY - rect.top) / rect.height;
        const clampedX = Math.min(1, Math.max(0, relX));
        const clampedY = Math.min(1, Math.max(0, relY));

        const tiltX = (0.5 - clampedY) * maxTilt * 2;
        const tiltY = (clampedX - 0.5) * maxTilt * 2;
        const dx = clampedX - 0.5;
        const dy = clampedY - 0.5;
        const intensity = Math.min(1, Math.sqrt(dx * dx + dy * dy) * 1.4);

        phone.style.setProperty("--phone-rx", `${tiltX.toFixed(2)}deg`);
        phone.style.setProperty("--phone-ry", `${tiltY.toFixed(2)}deg`);
        phone.style.setProperty("--phone-z", `${maxDepth}px`);
        phone.style.setProperty(
          "--phone-glow-opacity",
          `${(0.18 + intensity * 0.26).toFixed(3)}`
        );
        phone.style.setProperty(
          "--screen-glow-opacity",
          `${(0.08 + intensity * 0.2).toFixed(3)}`
        );

        rafId = null;
      };

      const onMove = (event) => {
        if (event.pointerType === "touch") return;
        lastEvent = event;
        if (rafId) return;
        rafId = requestAnimationFrame(updateTilt);
      };

      const resetTilt = () => {
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
        lastEvent = null;
        phone.style.removeProperty("--phone-rx");
        phone.style.removeProperty("--phone-ry");
        phone.style.removeProperty("--phone-z");
        phone.style.removeProperty("--phone-glow-opacity");
        phone.style.removeProperty("--screen-glow-opacity");
      };

      wrapper.addEventListener("pointermove", onMove);
      wrapper.addEventListener("pointerenter", onMove);
      wrapper.addEventListener("pointerleave", resetTilt);
    })();
  </script>
  <script is:inline>
    (() => {
      const phone = document.querySelector(".hero__phone");
      if (!phone) return;

      const powerButton = phone.querySelector("[data-phone-power]");
      const lockScreen = phone.querySelector("[data-lock-screen]");
      const volumeUp = phone.querySelector("[data-phone-volume-up]");
      const volumeDown = phone.querySelector("[data-phone-volume-down]");
      const volumeFill = phone.querySelector(".hero__phone-volume-fill");
      const volumeHud = phone.querySelector(".hero__phone-volume");

      let volume = 60;
      let hudTimer = null;
      let powerOn = !phone.classList.contains("is-off");

      const updateVolume = (next) => {
        volume = Math.min(100, Math.max(0, next));
        if (volumeFill) {
          volumeFill.style.height = `${volume}%`;
        }
        if (volumeHud) {
          volumeHud.classList.add("is-visible");
          if (hudTimer) window.clearTimeout(hudTimer);
          hudTimer = window.setTimeout(() => {
            volumeHud.classList.remove("is-visible");
          }, 900);
        }
      };

      const setPower = (next) => {
        powerOn = next;
        phone.classList.toggle("is-off", !powerOn);
      };

      const togglePower = () => {
        setPower(!powerOn);
      };

      powerButton?.addEventListener("click", togglePower);
      lockScreen?.addEventListener("click", () => {
        if (!powerOn) setPower(true);
      });
      volumeUp?.addEventListener("click", () => updateVolume(volume + 10));
      volumeDown?.addEventListener("click", () => updateVolume(volume - 10));

      updateVolume(volume);
    })();
  </script>
  <script is:inline>
    (() => {
      const videos = document.querySelectorAll("video[data-video-playlist]");
      if (!videos.length) return;

      const parseSources = (value) => {
        if (!value) return [];
        try {
          const parsed = JSON.parse(value);
          if (Array.isArray(parsed)) {
            return parsed.filter(
              (item) => typeof item === "string" && item.length > 0
            );
          }
        } catch {}
        return value
          .split(",")
          .map((item) => item.trim())
          .filter(Boolean);
      };

      const pickNextIndex = (currentIndex, total) => {
        if (total <= 1) return 0;
        let nextIndex = currentIndex;
        while (nextIndex === currentIndex) {
          nextIndex = Math.floor(Math.random() * total);
        }
        return nextIndex;
      };

      const setupPlaylist = (video) => {
        const sources = parseSources(video.dataset.videoPlaylist);
        if (!sources.length) return;
        let currentIndex = -1;

        const playNext = () => {
          currentIndex = pickNextIndex(currentIndex, sources.length);
          const nextSrc = sources[currentIndex];
          if (!nextSrc) return;
          video.src = nextSrc;
          video.load();
          const playPromise = video.play();
          if (playPromise && typeof playPromise.catch === "function") {
            playPromise.catch(() => {});
          }
        };

        video.addEventListener("ended", playNext);
        playNext();
      };

      videos.forEach(setupPlaylist);
    })();
  </script>
  <script is:inline>
    (() => {
      const form = document.querySelector("[data-contact-form]");
      if (!form) return;

      const statusEl = form.querySelector("[data-contact-status]");
      const submitButton = form.querySelector("[data-contact-submit]");

      const setStatus = (message, isSuccess) => {
        if (!statusEl) return;
        statusEl.textContent = message;
        statusEl.classList.toggle("is-success", Boolean(isSuccess));
        statusEl.classList.toggle("is-error", !isSuccess);
      };

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        if (submitButton) {
          submitButton.disabled = true;
          submitButton.setAttribute("aria-busy", "true");
        }
        setStatus("", true);

        try {
          const response = await fetch(form.action, {
            method: "POST",
            body: new FormData(form),
            headers: {
              Accept: "application/json",
            },
          });
          const data = await response.json().catch(() => ({}));
          if (response.ok) {
            setStatus("送信しました。確認次第ご連絡します。", true);
            form.reset();
          } else {
            setStatus(
              data?.error ??
                "送信に失敗しました。時間をおいて再度お試しください。",
              false
            );
          }
        } catch {
          setStatus(
            "送信に失敗しました。時間をおいて再度お試しください。",
            false
          );
        } finally {
          if (submitButton) {
            submitButton.disabled = false;
            submitButton.removeAttribute("aria-busy");
          }
        }
      });
    })();
  </script>
  <script is:inline>
    (() => {
      const form = document.querySelector("[data-chat-form]");
      const log = document.querySelector("[data-chat-log]");
      if (!form || !log) return;

      const input = form.querySelector(".chat-input");
      const submitButton = form.querySelector("[data-chat-submit]");
      const statusEl = form.querySelector("[data-chat-status]");
      const storageKey = "saip-chat-log";
      const MAX_MESSAGE_LENGTH = 50;
      let messages = [];

      const setStatus = (message) => {
        if (!statusEl) return;
        statusEl.textContent = message;
      };

      const scrollToBottom = () => {
        log.scrollTop = log.scrollHeight;
      };

      const createMessage = (role, content) => {
        const wrapper = document.createElement("div");
        wrapper.className = `chat-message chat-message--${role}`;
        const bubble = document.createElement("div");
        bubble.className = "chat-bubble";
        bubble.textContent = content;
        wrapper.appendChild(bubble);
        log.appendChild(wrapper);
        scrollToBottom();
        return bubble;
      };

      const createLoadingIndicator = () => {
        const wrapper = document.createElement("span");
        wrapper.className = "chat-loading";
        for (let i = 0; i < 3; i += 1) {
          const dot = document.createElement("span");
          dot.className = "chat-loading-dot";
          wrapper.appendChild(dot);
        }
        return wrapper;
      };

      const setBubbleLoading = (bubble, isLoading) => {
        if (isLoading) {
          bubble.classList.add("is-loading");
          bubble.textContent = "";
          bubble.appendChild(createLoadingIndicator());
          return;
        }
        bubble.classList.remove("is-loading");
        const indicator = bubble.querySelector(".chat-loading");
        if (indicator) indicator.remove();
      };

      const renderMessages = () => {
        log.innerHTML = "";
        messages.forEach((item) => {
          createMessage(item.role, item.content);
        });
      };

      const saveMessages = () => {
        try {
          const trimmed = messages.slice(-12);
          localStorage.setItem(storageKey, JSON.stringify(trimmed));
        } catch {}
      };

      const loadMessages = () => {
        try {
          const raw = localStorage.getItem(storageKey);
          if (!raw) return;
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) {
            messages = parsed.filter((item) => item?.role && item?.content);
          }
        } catch {}
      };

      const getLastExchange = () => {
        for (let i = messages.length - 1; i >= 0; i -= 1) {
          if (messages[i].role !== "assistant") continue;
          const assistant = messages[i];
          for (let j = i - 1; j >= 0; j -= 1) {
            if (messages[j].role === "user") {
              return {
                user: messages[j].content,
                assistant: assistant.content,
              };
            }
          }
          break;
        }
        return null;
      };

      loadMessages();
      renderMessages();

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        const value = input?.value?.trim();
        if (!value) return;
        if (value.length > MAX_MESSAGE_LENGTH) {
          setStatus(
            `メッセージは${MAX_MESSAGE_LENGTH}字以内で入力してください。`
          );
          return;
        }

        const history = getLastExchange();
        messages.push({ role: "user", content: value });
        createMessage("user", value);
        if (input) input.value = "";

        const assistantEntry = { role: "assistant", content: "" };
        messages.push(assistantEntry);
        const assistantBubble = createMessage("assistant", "");
        setBubbleLoading(assistantBubble, true);
        let hasStarted = false;
        let suppressOutput = false;

        const stripTrailingMetadataText = (text) => {
          const markers = ['{"tool_calls"', '{"response"', '{"usage"'];
          let cutIndex = -1;
          for (const marker of markers) {
            const idx = text.indexOf(marker);
            if (idx === -1) continue;
            if (cutIndex === -1 || idx < cutIndex) {
              cutIndex = idx;
            }
          }
          if (cutIndex === -1) return text;
          return text.slice(0, cutIndex).trimEnd();
        };

        const appendChunk = (chunkText) => {
          if (!chunkText || suppressOutput) return;
          const cleaned = stripTrailingMetadataText(chunkText);
          if (cleaned !== chunkText) {
            suppressOutput = true;
          }
          if (!cleaned) return;
          if (!hasStarted) {
            hasStarted = true;
            setBubbleLoading(assistantBubble, false);
          }
          assistantEntry.content += cleaned;
          const chunkEl = document.createElement("span");
          chunkEl.className = "chat-chunk";
          chunkEl.textContent = cleaned;
          assistantBubble.appendChild(chunkEl);
          scrollToBottom();
        };

        if (submitButton) {
          submitButton.disabled = true;
          submitButton.setAttribute("aria-busy", "true");
        }

        setStatus("送信中...");

        try {
          const response = await fetch("/api/chat", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "text/event-stream",
            },
            body: JSON.stringify({
              message: value,
              history: history ?? undefined,
            }),
          });

          if (!response.ok) {
            const responseText = await response.text().catch(() => "");
            let data = {};
            try {
              data = responseText ? JSON.parse(responseText) : {};
            } catch {}
            console.error("[chat] response error", {
              status: response.status,
              statusText: response.statusText,
              body: responseText,
            });
            throw new Error(data?.error ?? "送信に失敗しました。");
          }

          const contentType = response.headers.get("content-type") ?? "";
          if (!contentType.includes("text/event-stream")) {
            const responseText = await response.text().catch(() => "");
            let data = {};
            try {
              data = responseText ? JSON.parse(responseText) : {};
            } catch {}
            console.log("[chat] response body", responseText);
            const text = data?.text ?? "";
            if (!text) {
              console.warn("[chat] non-stream response without text", {
                contentType,
                body: responseText,
              });
            }
            setBubbleLoading(assistantBubble, false);
            const cleanedText = stripTrailingMetadataText(text);
            assistantEntry.content = cleanedText;
            assistantBubble.textContent = cleanedText;
            setStatus(cleanedText ? "" : "AIの応答が空でした。");
            saveMessages();
            return;
          }

          const reader = response.body?.getReader();
          if (!reader) {
            console.error("[chat] stream reader missing");
            throw new Error("ストリームが開始できません。");
          }

          setStatus("応答中...");

          const decoder = new TextDecoder();
          let buffer = "";
          let rawStream = "";
          const maxRawLog = 2000;

          const parseEvent = (event) => {
            const lines = event.split(/\r?\n/);
            let eventType = "message";
            const dataLines = [];
            for (const line of lines) {
              if (line.startsWith("event:")) {
                eventType = line.replace(/^event:\s*/, "").trim();
                continue;
              }
              if (line.startsWith("data:")) {
                dataLines.push(line.replace(/^data:\s*/, ""));
              }
            }
            return { eventType, data: dataLines.join("\n") };
          };

          const logStreamError = (payload, eventType) => {
            if (!payload) return;
            let parsed = null;
            try {
              parsed = JSON.parse(payload);
            } catch {}
            const parsedError =
              parsed && typeof parsed === "object"
                ? (parsed.error ?? parsed?.response?.error)
                : null;
            const errorEvent = eventType && /error|failed/i.test(eventType);
            const errorString =
              typeof payload === "string" &&
              (payload.startsWith("$error:") ||
                payload.toLowerCase().startsWith("error:"));
            if (!errorEvent && !parsedError && !errorString) return;
            console.error("[chat] stream error", {
              event: eventType,
              payload,
              parsed: parsed || undefined,
            });
          };

          const extractChunk = (raw) => {
            if (!raw || raw === "[DONE]") return "";
            const trimmed = raw.trim();
            if (
              trimmed.startsWith("$error:") ||
              trimmed.toLowerCase().startsWith("error:")
            ) {
              return "";
            }
            try {
              const parsed = JSON.parse(raw);
              if (typeof parsed === "string") return parsed;
              if (typeof parsed?.delta === "string") return parsed.delta;
              if (typeof parsed?.chunk === "string") return parsed.chunk;
              if (typeof parsed?.response === "string") return parsed.response;
              if (typeof parsed?.token === "string") return parsed.token;
              if (typeof parsed?.text === "string") return parsed.text;
              if (
                parsed &&
                typeof parsed === "object" &&
                ("response" in parsed ||
                  "chunk" in parsed ||
                  "token" in parsed ||
                  "text" in parsed ||
                  "usage" in parsed)
              ) {
                return "";
              }
              return raw;
            } catch {
              return raw;
            }
          };

          const flushEvents = (raw) => {
            const events = raw.split(/\r?\n\r?\n/);
            buffer = events.pop() ?? "";

            for (const event of events) {
              const { eventType, data } = parseEvent(event);
              if (data) {
                const textChunk = extractChunk(data);
                if (textChunk) {
                  appendChunk(textChunk);
                } else {
                  logStreamError(data, eventType);
                }
                continue;
              }

              const rawText = event.trim();
              if (!rawText) continue;
              const textChunk = extractChunk(rawText);
              if (textChunk) {
                appendChunk(textChunk);
              } else {
                logStreamError(rawText, eventType);
              }
            }
          };

          while (true) {
            const { value: chunk, done } = await reader.read();
            if (done) break;
            const decoded = decoder.decode(chunk, { stream: true });
            if (rawStream.length < maxRawLog) {
              rawStream += decoded.slice(0, maxRawLog - rawStream.length);
            }
            buffer += decoded;
            flushEvents(buffer);
          }

          if (buffer) {
            flushEvents(`${buffer}\n\n`);
          }

          if (!hasStarted) {
            setBubbleLoading(assistantBubble, false);
          }
          const cleanedText = stripTrailingMetadataText(assistantEntry.content);
          if (cleanedText !== assistantEntry.content) {
            assistantEntry.content = cleanedText;
            assistantBubble.textContent = cleanedText;
          }
          if (!assistantEntry.content) {
            console.warn("[chat] stream ended without content", {
              contentType,
              raw: rawStream,
            });
          }
          setStatus(assistantEntry.content ? "" : "AIの応答が空でした。");
          saveMessages();
        } catch (error) {
          const message =
            error instanceof Error ? error.message : "送信に失敗しました。";
          console.error("[chat] request failed", error);
          setBubbleLoading(assistantBubble, false);
          setStatus(message);
        } finally {
          if (submitButton) {
            submitButton.disabled = false;
            submitButton.removeAttribute("aria-busy");
          }
        }
      });
    })();
  </script>
</Layout>
